# Topics:

OOP Principles: Encapsulation, Inheritance, Polymorphism, Abstraction.
**********************************************************************************************************

## Encapsulation: like a smartphone has battery , camera , storage etc but these are not directly accessible rather these are accessible 
through apps.
so we keep data and methods secure in an object and refrain from directly accessing them
and only expose limited things which are necessary 
makes the code ---> easy , readable, maintainable , and the function have less parameters

## Abstraction: Complex inside and simple outside
for example in a coffee machine u dont know whats happening in the inside u just press a button and u get coffee
u should'nt know whats happening inside. 
these hidden complex processes simplify out interaction 
hiding intrnal things and only showing necessary things
if u anytime change your internal method then your overall program wont be affected

## Encapsulation
What it is: Bundling data (variables) and methods (functions) that operate on that data into a single unit, usually a class.
Purpose: To restrict direct access to internal details of an object. You expose only what’s necessary through getters, setters, or methods.
Think of it as: Data hiding.
           ##VS
## Abstraction
What it is: Hiding implementation details while showing only the essential features.
Purpose: To focus on what an object does, not how it does it.
Think of it as: Implementation hiding.

SO what are the main differences encapsulation does data hiding , bundles data and methods into a single unit to restrict direct access to internal details of an object whereas abstraction does implementation hiding implementation details focusing on what an object does rather that how it does it

## Inheritance: dont rewrite the code
allows a class to inherit properties and methods form another class
suppose u have a vehicle class which has bike and car as types of vehicles & have common property as speed fuel and engine
means the properties u define under the vehicle class will be automatically inherited by the car and bike class
so u dont need to redefine them --->> reduces redundancy
to change the child class u just need to modify the parent class

## Polymorphism: same function in different form 
suppose u have a function draw() now depending on the shapes this function could be implemented differently in many forms
in it u dont need if else or switch case statements


* 1. Compile-time Polymorphism (Method Overloading / Operator Overloading)
Same method name but different signatures (different parameters).
The compiler decides which one to call based on arguments.

* 2. Runtime Polymorphism (Method Overriding)
A child class provides its own version of a method already defined in the parent.
The method call is resolved at runtime, based on the actual object type.

Overloading: Same name, different parameters, chosen at compile time.
Overriding: Same name, same parameters, different behavior, chosen at runtime.

Polymorphism is basically the backbone of flexibility and extensibility in large systems. It lets you:
Write code to an interface, not a specific implementation.
Swap implementations without rewriting your code.
Add new functionality (new subclasses) without breaking existing code.

# Questions:
## What is polymorphism?

## Difference between overloading and overriding?

## Is overloading runtime or compile-time? (→ compile-time)

## Can you override a static method? (→ no, static methods belong to the class, not the object)

## Can constructors be overridden? (→ no, they can only be overloaded)
(
1. What overriding really means
Overriding = same method signature in parent and child, and at runtime the child’s method gets called instead of parent’s.
It relies on dynamic dispatch (runtime polymorphism).
For that to work, the method must be inherited by the child.
2. Why constructors don’t qualify
Constructors are not inherited by child classes.
Every class in Java defines its own constructors.
When you write new Child(), the Child’s constructor is invoked directly — there’s no question of overriding a parent constructor.
So, overriding doesn’t apply, because there’s no parent constructor method being passed down to the child in the first place.
3. What you can do instead (Overloading)
You can have multiple constructors in the same class with different parameter lists — that’s overloading

class Person {
    Person() { System.out.println("Default constructor"); }
    Person(String name) { System.out.println("Name: " + name); }
}
→ Two constructors with different signatures = overloading.

)


4. Higher-level / Gotchas
Can you override a private method? (→ No, it’s not visible to child classes, but you can create a new one in child = method hiding).
What happens if you override equals() but not hashCode()? (→ Breaks polymorphic behavior in collections like HashMap/HashSet).
Why is polymorphism essential in frameworks like Spring, Hibernate, React (JS), etc.?


1. Concept Checks
What is encapsulation?
Difference between encapsulation and abstraction?
How does access modifier (private, protected, public) enforce encapsulation?
2. Real-world Questions
How would you protect sensitive fields like passwords in a User class?
Why should fields in a DTO (Data Transfer Object) still be encapsulated?
What happens if you don’t encapsulate when working in a team project?
3. Gotchas
Does encapsulation improve security? → No, it doesn’t make data “secure” in a cryptographic sense, it just enforces controlled access.
Is using private always enough? → No, you also need to expose controlled setters/getters.


1. Concept Checks
What is abstraction?
Difference between abstract class and interface?
When would you use abstract class vs interface?

Q: Can we instantiate an abstract class?
No, but we can hold a reference of type abstract class pointing to a subclass.
Q: Can an interface have a constructor?
No, interfaces cannot be instantiated.

If you’re designing a payment system, how would abstraction help?
(Answer: Create PaymentGateway interface → PayPal, Stripe implement it.)
Why is abstraction important in large codebases?
(Answer: Allows working at a high-level API without caring about implementation details.)


1. Concept Checks
What is inheritance?
Types of inheritance in Java? (Single, Multilevel, Hierarchical → but not multiple due to ambiguity)
Why does Java not support multiple inheritance with classes?

Q: Can constructors be inherited?
No.

Can we override private methods? → No, they are not inherited.
Can a child access parent’s private variables? → No, only through protected/public getters/setters.

12. Method hiding vs overriding (refer Q3 png)
Hiding: Static methods, resolved at compile time, no polymorphism.
Overriding: Instance methods, resolved at runtime, supports polymorphism.

13. Why composition over inheritance sometimes
Inheritance = tight coupling, fragile base class issues.
Composition = more flexible (you can swap parts out without breaking hierarchy).

1. Difference between abstract class and interface
Abstract class: Can have abstract + concrete methods, state (fields), constructors, any access modifier.
Interface: Defines a contract, can’t hold state (except static final constants), all methods are abstract by default (till Java 7), can have default and static methods (Java 8+).

2. When to use abstract class vs interface
Abstract class: When classes share common state/behavior.
Interface: When you just want to define capabilities or contracts across unrelated classes.

3. Protecting sensitive fields like passwords
Make the field private.
Don’t expose raw value in a getter.
Store hashed/encrypted password, not plaintext.

5. What if you don’t encapsulate in a team project
Anyone can directly modify internal state.
Leads to bugs, harder debugging, tight coupling.

6. How access modifiers enforce encapsulation(how much of limited access we have)
private: Only inside same class.
protected: Same package + subclasses.
public: Anywhere.
This lets you control how much of your class is exposed.

7. Can we instantiate an abstract class?
No.
But you can write:
# Shape s = new Circle();  // Shape is abstract
The reference is abstract type, but the object is concrete subclass.

8. Can an interface have a constructor? How?
No, because interfaces cannot be instantiated.
They only define behavior — classes implementing them provide constructors.

9. Why does Java not support multiple inheritance with classes?
To avoid the diamond problem (ambiguity when two parents define same method).
Interfaces solve this safely because they don’t hold state.


**********************************************************************************************************

CS Fundamentals refresher:

OS: Processes, threads, synchronization, deadlocks.

DBMS: Normalization, indexes, transactions (ACID).

Networks: TCP vs UDP, DNS, HTTP, sockets.

Resources:

Head First Design Patterns (easy read).

Refactoring Guru (site for patterns).

GFG/JavaTpoint (for quick DBMS/OS/Networks revision).

Output: Be able to design small class diagrams and code for toy problems.